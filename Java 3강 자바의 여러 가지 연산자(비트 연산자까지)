Java Programming

3) 자바의 여러 가지 연산자(비트 연산자까지)

3-2) 비트 연산자
: 비트 단위로 연산이 이루어지는 연산자
1. 암호화 작업처럼 임의의 숫자를 만들거나, 어떤 변수의 특정 비트를 꺼낼때(마스킹) 사용
2. 하드웨어에 임베디드 시스템 프로그램에서 메모리 용량이 부족하거나 계산이 복잡해서 속도가 느려질때, 속도를 빠르게 만들 수 있다.
=> Java에서는 특정 값을 만들거나 연산할때 비트 연산자를 사용한다!

= 비트 논리 연산자
: &, |, ^, ~ 로 이루어져있다.

1) & 연산자(AND 연산자)
: 두 개의 비트 값이 모두 1인 경우에만 연산의 결과 값이 1이 된다.

예) 5와 10을 & 연산하는 경우			 num1 : 00000101
int num1 = 5;					&num2 : 00001010
int num2 = 10;					----------------
int result = num1 & num2;		result: 00000000 = 0

=> 0&0 -> 0 , 0&1 -> 0 , 1&0 -> 0 , 1&1 -> 1

2) | 연산자(OR 연산자)
: 비트 값이 하나라도 1이면 연산 결과 값이 1이 된다.

예) 5와 10을 | 연산하는 경우			 num1 : 00000101
int num1 = 5;					|num2 : 00001010
int num2 = 10;					----------------
int result = num1 & num2;		result: 00001111 = 15

=> 0|0 -> 0 , 0|1 -> 1 , 1|0 -> 1 , 1|1 -> 1

3) ^ 연산자(XOR 연산자)
: 같은 값이면 0, 다른 값이면 1의 결과 값을 갖는다.

예) 5와 10을 ^ 연산하는 경우			 num1 : 00000101
int num1 = 5;					^num2 : 00001010
int num2 = 10;					----------------
int result = num1 & num2;		result: 00001111 = 15

=> 0^0 -> 0 , 0^1 -> 1 , 1^0 -> 1, 1^1 -> 0

4) ~ 연산자(반전 연산자)
: 비트 값을 0은 1로, 1은 0으로 바꾸는 연산자

예) 10의 반전						 num : 00001010
int num = 10;					---------------
int result = ~num;				~num : 11110101

=> ~0 -> 1 , ~1 -> 0


= 비트 이동 연산자(shift 연산자)
: <<, >>, >>> 이렇게 세 가지가 있다. 

1) << 연산자
: 왼쪽으로 비트를 이동하는 연산자

예)
int num 5;						num :      00001010 = 5
num << 2;						num << 2 : 00101000 = 20

=> 왼쪽으로 n비트 이동한다는 것은 기존 값에서 2의 n제곱만큼 곱해진다는 의미이다.

2) >> 연산자
: 오른쪽으로 비트를 이동하는 연산자

예)
int num = 10;					num :	   00001010 = 10
num >> 2;						num >> 2 : 00000010 = 2

=> 오른쪽으로 n비트 이동한다는 것은 기존 값에서 2의 n제곱만큼 나눠딘다는 의미이다.

3) >>> 연산자
: 오른쪽으로 이동시키면서 왼쪽에 채워지는 비트 값이 부호 비트와 상관없이 무조건 0이 된다.  

-------------------------------------------------------------------------------
package chap3;

public class OperationEx5 {
	public static void main (String[] args) {
		int num = 0B00000101;	//5를 8비트 2진수로 나타냄
		
		System.out.println(num << 2); //왼쪽으로 2비트 이동 00010100(20)
		System.out.println(num >> 2); //오른쪽으로 2비트 이동 00000001(1)
		System.out.println(num >>> 2); //오른쪽으로 2비트 이동 00000001(1)
		
		System.out.println(num);	//num에 값을 대입하지 않았으므로 비트 이동과 관계없이 기존 값 그대로 출력
		
		num = num << 2;				//왼쪽으로 2비트 이동한 값을 다시 num에 대입
		System.out.println(num);
	}
}
-------------------------------------------------------------------------------
5
20
1
1
20
-------------------------------------------------------------------------------


= 연산자 우선순위
1) 단항 연산자가 가장 높고 이항, 삼항 연산자 순서이다.
2) 대입 연산자의 우선순위가 가장 낮다.
3) 산술, 관계, 논리, 개입 연산자 순서로 우선순위를 가지며 ()의 우선순위가 가장 높다.

우선순위	형		연산자			 연산 방향
1		일차식	(), []			 ----->
2		단항		! ++ -- + -		 <-----
3		산술		% /				 ----->
4		산술		+ -				 ----->
5		비트 이동	<< >>			 ----->
6		관계		< > <= >=		 ----->
7		관계		== !=			 ----->
8		비트 곱	&				 ----->
9		비트 차	^				 ----->
10		비트 합	|				 ----->
11		논리 곱	&&				 ----->
12		논리 합	||				 ----->	
13		조건		? :				 ----->
14		대입		= += -= *= %= /= <-----


연습문제1
-------------------------------------------------------------------------------
package chap3;

public class Operation_Practice {
	public static void main(String[] args) {
		int myAge = 23;
		int teacherAge = 38;
		
		boolean value = (myAge > 25);
		System.out.println(value);		//false
		
		System.out.println(myAge <= 25);		//true
		System.out.println(myAge==teacherAge);	//false
		
		char ch;
		ch = (myAge > teacherAge) ? 'T' : 'F';
		
		System.out.println(ch);	//F
	}
}
-------------------------------------------------------------------------------

연습문제2
-------------------------------------------------------------------------------
package chap3;

public class Practice2 {
	public static void main(String[] args) {
		int num;
		num = -5 + 3 * 10 / 2;		//10
		System.out.println(num);
	}
}
-------------------------------------------------------------------------------

연습문제3
-------------------------------------------------------------------------------
package chap3;

public class Practice3 {
	public static void main(String[] args) {
		int num = 10;
		
		System.out.println(num);	//10
		System.out.println(num++);	//10
		System.out.println(num);	//11
		System.out.println(--num);	//10
	}
}
-------------------------------------------------------------------------------


연습문제4
-------------------------------------------------------------------------------
package chap3;

public class Practice4 {
	public static void main(String[] args) {
		int num1 = 10;
		int num2 = 20;
		boolean result;
												
		result = ((num1 > 10) && (num2 > 10));	
		System.out.println(result);				// F 
		result = ((num1 > 10) || (num2 > 10));	
		System.out.println(result);				// T
		System.out.println(!result);			// F
	}
}
-------------------------------------------------------------------------------

연습문제5
-------------------------------------------------------------------------------
package chap3;

public class Practice5 {
	public static void main(String[] args) {
		int num1 = 2;
		int num2 = 10;
		
		System.out.println(num1 & num2);	// 2
		System.out.println(num1 | num2);	// 10
		System.out.println(num1 ^ num2);	// 8
		System.out.println(~num1);			// -3
	}
}
-------------------------------------------------------------------------------
=> 마지막 값은 11111101이 되기에 보수는 00000011가 된다. 그렇기에 -3이 된다.
-------------------------------------------------------------------------------

연습문제6
-------------------------------------------------------------------------------
package chap3;

public class Practice6 {
	public static void main(String[] args) {
		int num = 8;
		
		System.out.println(num += 10);	// 18
		System.out.println(num -= 10);	// 8
		System.out.println(num >>= 2);	// 2
	}
}
-------------------------------------------------------------------------------

연습문제7
-------------------------------------------------------------------------------
package chap3;

public class Practice7 {
	public static void main(String[] args) {
		int num1 = 10;
		int num2 = 20;
		
		int result = (num1 >= 10) ? num2 + 10 : num2 - 10;
		System.out.println(result); // 30		
	}
}
-------------------------------------------------------------------------------
















